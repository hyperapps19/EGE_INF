### Как решать:
- Шаг 1: переконвертировать исходный файл в удобный для парсинга csv.
- Дальше действуем по одному из алгоритмов описанных ниже

### Просто посчитать количество секунд: минимальное для всех процессов, завершившиеся за n первых, n последних секунд и т.д.
- Берем функцию fill_tree, получаем ретурн, и сортируем.

### Если неизвестно время какого-то процесса.
- Сказанно что число целочисленное и так как это время, то начнем с 0. Меняем в csv t на 0. [Дальнейшее решение..](./time_process.py)

### Если неизвестен один зависимый пид, но известно минимальное время к которому нужно прийти. 
- Идея в том чтобы заменить в оригинальном файле пид на число(изначально 0 тк процесс может не от кого не зависеть) и побрутить его, однако здесь есть нюанс: брутить надо числа которые НЕ ЗАВИСЯТ от процесса у которого неизвестен предок, иначе произойдет зацикливание. [Мое решение](./process_pid.py)

### При выполнении с задержкой просто плюсуем ее. Ничего сложного

TODO:
- вычислит ядра
- попробовать обобщить все
